Il sistema funziona sia su Windows, sia su Linux anche in modalità mista (server Windows, client Linux e viceversa).

---------------------------------------------------------------------
Deamon sotto linux

Linea di comando su windows
---------------------------------------------------------------------
client e server usano richiesta-risposta sincrono
client e server usano autenticazione che permette solamente a client autorizzati di effettuare richieste al server

parametri opzionali:

	-p <TCP port>		porta TCP su cui stare in ascolto (default 8888);

	-n <thread max>		numero massimo di thread per gestire le richieste (default 10);	

	-c <path file>		percorso di configurazione;

	-s					stampa su stdout il token T_s quando viene generato;

	-l <path file>		percorso di log (default /tmp/server.log) 


---------------------------------------------------------------------
Avvio Server

all'avvio chiede da terminale di inserire una master key (passphrase)

	con la passphrase si genererà il token T_s

Al termine del processo di generazione del token il buffer utilizzato per leggere la passphrase deve essere azzerato.

il server si mette in attesa di connessioni sulla porta TCP 8888
	modificabile tramite opzione (-p) 
	modificabile tramite file di configurazione (-c)

---------------------------------------------------------------------

Il server crea inizialmente un pool di thread 
	Il numero di thread è specificabile da linea comandi (opzione -n) o da file di configurazione. 

Se nessun thread è disponibile per gestire una richiesta, la richiesta rimane in sospeso fino a quando un thread non è disponibile.

---------------------------------------------------------------------

i thread devono loggare sul file (-l) le richieste dai client autenticati (le richieste dai client dopo che hanno ricevuto il codice 200 a seguito del comando AUTH); 

utilizzare un meccanismo di lock, per il file log, a scelta tra quelli visti durante il corso (Nella relazione finale, motivare la scelta)

il file di log contiene una riga per ogni richiesta. Ogni riga contiene le seguenti informazioni:

	[timestamp] [thpid] [ip:port] [command]



timestamp: dataora/timestamp che identifichi quando è arrivata la richiesta

thpid: id del thread che ha ricevuto la richiesta

ip:port: indirizzo IP e porta del client

command: il tipo di richiesta (LSF, EXEC, DOWNLOAD, SIZE, UPLOAD);

---------------------------------------------------------------------
in linux

il server è in grado di rileggere il file di configurazione e, se necessario, modificare la porta TCP ed il numero massimo di thread. 
	la rilettura è attivata quando il server riceve il segnale SIGHUP (kill -HUP <processID>)

se non è specificato un file di configurazione, la ricezione del segnale SIGHUP non produrrà alcun effetto.

---------------------------------------------------------------------

protocollo di comunicazione tra client e server:

	HELO 

	AUTH <enc1;enc2>
	: più avanti c'è l'algoritmo

	LSF <path>
	: richiede la lista di file e directory contenuti in path (non entra nelle eventuali sottocartelle).

	EXEC <cmd num_args [args...] >
	: esegue il comando specificato da cmd [args..]
	: ritorna lo stdout del programma se questo termina correttamente (valore di ritorno = 0) 
	: oppure il valore di ritorno nel caso ci sia stato un errore

	DOWNLOAD <path;size>
	: richiede che il server si prepari a ricevere un file di size byte e lo salvi sul path specificato.

	SIZE <path>
	: ritorna la dimensione in byte del file (unsigned long int) indicato da path. (É un comando ausiliario usato prima del comando UPLOAD per conoscere la dimensione in byte del file)

	UPLOAD <path,size>
	: richiede che il server invii i primi size byte del contenuto del file identificato da path.

---------------------------------------------------------------------

Stauts Code server

	200
	: indica che l'operazione è andata a buon fine. 

	300
	: indica che il server invierà ulteriore output. 
	: Utilizzato per indicare l'invio della lista dei file come risposta dei comandi LSF e EXEC 
	: per l’invio della challenge di autenticazione come risposta del comando HELO
	: per l'invio della size del comando SIZE.

	400
	: indica che l'operazione ha prodotto un errore. Ad esempio il path non esiste, oppure il comando non esiste.

---------------------------------------------------------------------
Autenticazione



Il server in risposta al comando HELO:
	invia il codice 300, a seguire un unsigned long int che rappresenta la challenge di autenticazione, come descritta in seguito nel protocollo di autenticazione.

---------------------------------------------------------------------
Risposta comandi

In riposta al comando SIZE 
	invia il codice 300 a seguire un unsigned long int che rappresenta la size in byte del file richiesto.


In risposta al comando LSF
	il server invia il codice 300, a seguire, la lista dei file come una serie di record testuali (un record per ogni file) aventi la seguente struttura: "dimensione (in byte)" "path del file". 
	I record di aggiornamento sono separati tra di loro dalla sequenza "\r\n"  e la file della lista è indicata dalla sequenza " \r\n.\r\n".

In risposta al comando EXEC, il server invia il codice 300 e, a seguire, lo stdout se il programma ha terminato correttamente oppure il valore di ritorno nel caso ci sia stato un errore. Il server invia il contenuto dello stdout una linea alla volta e alla fine conclude con la sequenza " \r\n.\r\n"; nel caso in cui il server invii il valore di ritorno lo invia su una linea, terminata con la sequenza " \r\n.\r\n".

Il server deve supportare almeno i seguenti comandi tramite la richiesta EXEC :

copy <src> [<src>...] <dst>: copia src in dst. Se ci sono più src, dst deve essere una directory

remove <file> [<file>...] : rimuove il/i file che sono passati come argomenti

whoami: stampa utente

printworkdir: ritorna la working directory

sort <file>: stampa il contenuto di file ordinato lessicograficamente



Il protocollo di autenticazione prevede la definizione della funzione unsigned long int generateToken(const char *passphrase), in grado di generare un token a partire da una passphrase di lunghezza variabile; è richiesto che, data la stessa passphrase in  input venga generato lo stesso output.  Il protocollo di autenticazione prevede i seguenti passi:

Il server chiama la funzione generateToken per calcolare, a partire dalla server-passphrase, il token T_s che identifica il server;

Ogni client utilizza la funzione generateToken per calcolare il token T_s utilizzando la server-passphrase ed un token T_c_i a partire dalla client_i-passphrase.

Il client  invia un messaggio di HELO a cui il server risponde con un codice di risposta 300 ed invia poi un unsigned long int che contiene la challenge.  Il valore che viene inviato dal server è calcolato effettuando lo XOR del token T_s e della challenge, un unsigned long int scelto dal server in maniera random.

Il client estrae la challenge, utilizzando il valore di T_s  che ha calcolato al passo 2. Invia poi al server un messaggio AUTH <enc1;enc2> dove enc1_c=(T_s 	XOR T_c_i ) e enc2_c=(T_c_i XOR challenge).

Il server estrae da enc1 la chiave T_c_i e la utilizza per verificare da enc2 la challenge; se il valore è corretto risponde con un codice 200 altrimenti con un codice 400 e chiude la comunicazione.

I comandi del client sono specificati da linea comandi utilizzando le seguenti opzioni (o con equivalenti sottocomandi):

-l  <path> richiede la lista dei file presenti nella cartella (corrisponde al comando LST);

-e <cmd [args ...]> richiede che venga eseguito sul server il comando specificato da cmd [args..] e che venga ritornato il valore di ritorno di esecuzione del comando (corrisponde al comando EXEC);

-d  <src-path> <dest-path> richiede  che il server si prepari a ricevere il file identificato da <src-path> (client) e lo salvi su <dest-path> (server) (corrisponde al comando DOWNLOAD);

-u <src-path> <dest-path> richiede  che il server invii identificato da <src-path> (server) e che questo venga salvato su <dest-path> (client) (corrisponde al comando UPLOAD).

Quando un client viene avviato richiede, oltre all'opzione relativa al comando da inviare al server, anche 2 parametri obbligatori, l'indirizzo ip del server (opzione -h) e la porta su cui il server è in ascolto (opzione -p).

Prima di stabilire la connessione con il server, ogni client richede l'inserimento di due passphrase: quella utilizzata all'avvio del server server-passphrase, ed una specifica per ogni client, client-passphrase (es. i-esimo client avrà la passphrase client_i-passphrase). Queste passphrase saranno utilizzate per la procedura di autenticazione. Il primo messaggio che il client deve inviare dopo l'avvenuta connessione è un messaggio di HELO  per ricevere la challenge da utilizzare nel messaggio AUTH. Dopo che l'autenticazione è andata a buon fine il client può inviare la richiesta al server.

Il progetto può essere sviluppato da una o da due persone.

Al progetto andra' allegata una breve (5-10 pagine) relazione che descriva (e motivi) le scelte progettuali.